#!/bin/sh
###############################################################################
# BleemSync Function Library - BleemSync
# ModMyClassic.com / https://discordapp.com/invite/8gygsrw
###############################################################################

### LOCAL FUNCTIONS ###########################################################
launch_RetroArch(){
	echo "[BLEEMSYNC](INFO) launching RetroArch"
	while true; do
		killall -s KILL showLogo sonyapp ui_menu auto_dimmer pcsx sdl_display
		[ ! -d "$mountpoint/bleemsync/opt/retroArch" ] && mkdir -p "$mountpoint/bleemsync/opt/retroarch"
		[ -d "$runtime_log_path/retroarch.log" ] && rm -f "$runtime_log_path/retroarch.log" 
		[ ! -f "$mountpoint/bleemsync/opt/retroArch/retroarch" ] && break #FAIL
		if [ ! -f "$mountpoint/bleemsync/opt/retroArch/retroarch/system/scph102b.bin" ]; then
			cp -f "/gaadata/system/bios/romw.bin" "$mountpoint/bleemsync/opt/retroArch/retroarch/system/scph102b.bin"
			echo "[BLEEMSYNC](INFO) copied romw.bin to scph102b.bin for RA PCSX"
		fi
		mkdir -p "/tmp/ra_cache"
		chmod +x "$mountpoint/bleemsync/opt/retroArch/retroarch"
		export HOME="$mountpoint/bleemsync/opt/retroArch"
		$mountpoint/bleemsync/opt/retroArch/retroarch -v &> "$runtime_log_path/retroarch.log"
		rm -rf "/tmp/ra_cache"
		cd / &&	sync
		launch_BootMenu
	done
	#you done goofed.
	/media/bleemsync/bin/sdl_display "/media/bleemsync/etc/bleemsync/IMG/woah.png"
	sleep 1
	echo "[BLEEMSYNC](FAIL) tried to launch RetroArch and it's not installed! Opening Stock UI..."
	launch_BootMenu
}

launch_BootMenu(){
	echo "[BLEEMSYNC](INFO) launching BootMenu"
	$mountpoint/bleemsync/bin/boot_menu 
	[ -f "/tmp/launchfilecommand" ] && command=$(cat "/tmp/launchfilecommand")
	if [ "$command" = "/media/lolhack/retroarch.sh" ]; then
		echo "[BLEEMSYNC](INFO) RA selected from boot menu. Launching RetroArch"
		launch_RetroArch
	else
		echo "[BLEEMSYNC](INFO) BS selected from boot menu (or failsafed). Launching stock UI"
		launch_StockUI
	fi
}

launch_StockUI(){
	echo "[BLEEMSYNC](INFO) launching stock UI"
	cd "/data/AppData/sony/pcsx"
	export PCSX_ESC_KEY=2
	/usr/sony/bin/ui_menu --power-off-enable &> "$runtime_log_path/ui_menu.log"
}
###############################################################################

###	UI_MENU -> RETROARCH INTERACTION FUNCTIONS ################################

#	The follow variables will need to have been gathered from an intercept script
#	prior to these functions being called
#
#
#	intercept_game_path="" 		# The full path to the launching game file (follows argument -cdfile)
#	intercept_game_dir="" 		# The directory game launched from - should be /data/AppData/sony/title
#	intercept_game_id="" 		# The file name of the game minus the extension (ie. SCUS-0001)
#	intercept_game_ext="" 		# The extension of game minus . (ie. cue)
#	intercept_save_state=false 	# Set to true if ui_menu launches with -load
#
##

exit_checkSaveState(){

	# This function should only be called from the intercept script after RetroArch exits

	echo "[BLEEMSYNC](INFO) checking for auto save state on RetroArch exit"

	# An auto save state is created automatically, but what if the game disc was changed since
	# RetroArch was originally launched. Check that the last saved state matches the ID of the launching
	# game
    
    ra_last_game=`ls -t $mountpoint/bleemsync/opt/retroArch/savestates/*.auto | head -1`
    ra_last_game="${ra_last_game##*/}"          #   Remove leading directories
    ra_last_game="${ra_last_game%.state.auto}"  #   Remove trailing file extension .state.auto

    if [ ! "$ra_last_game" == "$intercept_game_id" ]; then
        
		#   The last save state was for a different game, check if this disc belongs to the launching game
		#	If it does then a disc swap has occured, so update the game ids so the correct save state
		#	data is passed to ui_menu
        echo "[BLEEMSYNC](INFO) last auto save state is from a game which is different to the launched game"

        if [ -f "/data/AppData/sony/title/${ra_last_game}.${intercept_game_ext}" ]; then

			echo "[BLEEMSYNC](INFO) ${ra_last_game}.${intercept_game_ext} exists and belongs to the launching game, updating save state"
            intercept_game_path="/data/AppData/sony/title/${ra_last_game}.${intercept_game_ext}"
            intercept_game_id=$ra_last_game
			
			echo "[BLEEMSYNC](INFO) New game path: $intercept_game_path"
            
            echo "[BLEEMSYNC](INFO) New Game ID: $intercept_game_id"
        fi
    else
        echo "We same game boys"
    fi

	#	Check if an auto save state exists and then move it to the correct location for ui_menu to handle

    if [ -f $mountpoint/bleemsync/opt/retroArch/savestates/${intercept_game_id}.state.auto ]; then
		echo "[BLEEMSYNC](INFO) an auto save state exists"

		#	Create filename.txt
        echo $intercept_game_path > /data/AppData/sony/pcsx/.pcsx/filename.txt
        echo $intercept_game_id >> /data/AppData/sony/pcsx/.pcsx/filename.txt

		#	Move save state files
        mv $mountpoint/bleemsync/opt/retroArch/savestates/${intercept_game_id}.state.auto /data/AppData/sony/pcsx/.pcsx/sstates/${intercept_game_id}.000
        mv $mountpoint/bleemsync/opt/retroArch/savestates/${intercept_game_id}.state.auto.png /data/AppData/sony/pcsx/.pcsx/screenshots/${intercept_game_id}.png
        
    fi

	#	Remove any remaining auto save states. We're completly hijacking the auto-save state process
	#	so these need to be removed to ensure things work correctly
    #	F for orphaned auto saves
    rm $mountpoint/bleemsync/opt/retroArch/savestates/*.auto
}


###############################################################################

execute_bleemsync_func(){
	echo "[BLEEMSYNC](Executing) execute_bleemsync_func()"
	echo 1 > /sys/class/leds/red/brightness
	
	if [ -f "$mountpoint/System/BleemSync/BleemSync" ]
	then
		cd "$mountpoint/System/BleemSync"
		chmod +x "BleemSync"
		./BleemSync
		cd -
	fi

	# Extract system files to avoid crashing
	mkdir -p "$mountpoint/System/Bios"
	mkdir -p "$mountpoint/System/Preferences"
	mkdir -p "$mountpoint/System/Preferences/System"
	mkdir -p "$mountpoint/System/Preferences/User"
	mkdir -p "$mountpoint/System/Preferences/AutoDimmer"
	mkdir -p "$mountpoint/System/Databases"
	mkdir -p "$mountpoint/System/Region"
	mkdir -p "$mountpoint/System/UI"

	# Copy the BIOS files to USB
	[ ! -f "$mountpoint/System/Bios/romw.bin" ] && cp -fr "/gaadata/system/bios/"* "$mountpoint/System/Bios"
	# Copy the regional.pre to USB
	# This contains settings for the UI region
	[ ! -f "$mountpoint/System/Preferences/System/regional.pre" ] && cp -f "/gaadata/preferences/"* "$mountpoint/System/Preferences/System"
	# Copy out the user.pre to USB
	# This contains things like language setting
	[ ! -f "$mountpoint/System/Preferences/User/user.pre" ] && cp -f "/data/AppData/sony/ui/"* "$mountpoint/System/Preferences/User"
	# Copy out the auto dimming config to USB
	[ ! -f "$mountpoint/System/Preferences/AutoDimmer/config.cnf" ] && cp -f "/data/AppData/sony/auto_dimmer/"* "$mountpoint/System/Preferences/AutoDimmer"
	# Copy out the region info
	[ ! -f "$mountpoint/System/Region/REGION" ] && cp -f "/gaadata/geninfo/"* "$mountpoint/System/Region"
	# Copy ui error log
	[ ! -f "$mountpoint/System/UI/error.log" ] && cp -f "/data/sony/ui/"* "$mountpoint/System/UI"
	sync

	# Unmount partitons and create tmpfs - Shut system down on failure
	MOUNT_FAIL=0
	umount /data || MOUNT_FAIL=1 
	umount /gaadata || MOUNT_FAIL=1 
	# Create gaadata and data folders in tmp then mount over original folders
	mkdir -p "/tmp/gaadatatmp" "/tmp/datatmp"
	mount -o bind "/tmp/gaadatatmp" "/gaadata" || MOUNT_FAIL=1 
	mount -o bind "/tmp/datatmp" "/data" || MOUNT_FAIL=1 
	mount -o bind "$bleemsync_path/etc/bleemsync/SUP/scripts/20-joystick.rules" "/etc/udev/rules.d/20-joystick.rules" || MOUNT_FAIL=1 
	if [ "$MOUNT_FAIL" = "1" ]; then
		#display error message
		echo 0 > /sys/class/leds/green/brightness
		echo 1 > /sys/class/leds/red/brightness
		reboot
		exit 1
	fi

	# Create gaadata on tmpfs
	mkdir -p "/tmp/gaadatatmp/system/"
	ln -s "$mountpoint/System/Databases" "/tmp/gaadatatmp/databases"
	ln -s "$mountpoint/System/Region" "/tmp/gaadatatmp/geninfo"
	ln -s "$mountpoint/System/Bios" "/tmp/gaadatatmp/system/bios"
	ln -s "$mountpoint/System/Preferences/System" "/tmp/gaadatatmp/preferences"
	ls "$mountpoint/Games" | grep '^[0-9]\+$' | xargs -I % sh -c "ln -s $mountpoint/Games/%/GameData /tmp/gaadatatmp/% && mkdir -p $mountpoint/Games/%/.pcsx && cp $mountpoint/Games/%/GameData/pcsx.cfg $mountpoint/Games/%/.pcsx"

	# Create data on tmpfs
	mkdir -p "/tmp/datatmp/sony/sgmo" "/tmp/datatmp/AppData/sony"
	ln -s "/tmp/diag" "/tmp/datatmp/sony/sgmo/diag"
	ln -s "/dev/shm/power" "/tmp/datatmp/power"
	ln -s "$mountpoint/System/UI" "/tmp/datatmp/sony/ui"
	ln -s "$mountpoint/System/Preferences/User" "/tmp/datatmp/AppData/sony/ui"
	ln -s "$mountpoint/System/Preferences/AutoDimmer" "/tmp/datatmp/AppData/sony/auto_dimmer"
	cp -fr "/usr/sony/share/recovery/AppData/sony/pcsx" "/tmp/datatmp/AppData/sony/pcsx"
	ls "$mountpoint/Games" | grep '^[0-9]\+$' | xargs -I % sh -c "rm -rf /tmp/datatmp/AppData/sony/pcsx/% && ln -s $mountpoint/Games/% /tmp/datatmp/AppData/sony/pcsx/%"
	ln -s "$mountpoint/System/Bios" "/tmp/datatmp/AppData/sony/pcsx/bios"
	ln -s "/usr/sony/bin/plugins" "/tmp/datatmp/AppData/sony/pcsx/plugins"

	# Fix for last selected game issue. If not in place user may experience UI issue
	sed -i "s/iUiUserSettingLastSelectGameCursorPos.*/iUiUserSettingLastSelectGameCursorPos=0/" "/tmp/datatmp/AppData/sony/ui/user.pre"

	# Reload and apply udev rules that were overmounted above
	# Allows both controllers to be detected through a USB hub
	udevadm control --reload-rules
	udevadm trigger

	# Default pcsx.cfg
	cd "$mountpoint/Games"
	for D in *; do
		if [ -d "$D" ]; then
			if [ ! -f "$D/GameData/pcsx.cfg" ]; then
				cp -f "../System/Defaults/pcsx.cfg" "$D/GameData/pcsx.cfg"
			fi
		fi
	done
	cd -

	#Patch out health check if toggled.
	if [ "$boot_disable_health" = "1" ]; then
		echo "[BLEEMSYNC](INFO) attempting to patch out H+S statement"
		PATCH_FAIL=0
		PATCH_DIR="/tmp/health_patch"
		PATCH_BIN="$PATCH_DIR/patch.bin"
		PATCH_TARGET="/usr/sony/bin/ui_menu"
		PATCH_WORKING="$PATCH_DIR/ui_menu"

		# Perform patching
		mkdir -p "$PATCH_DIR"
		cp -f "$PATCH_TARGET" "$PATCH_WORKING"
		echo -n -e '\xb8\x0c\x00\x06\x03\x58\xbe' > "$PATCH_BIN"
		dd bs=1 if="$PATCH_BIN" skip=0 of="$PATCH_WORKING" seek=28084 count=3 conv=notrunc
		dd bs=1 if="$PATCH_BIN" skip=3 of="$PATCH_WORKING" seek=28120 count=2 conv=notrunc
		dd bs=1 if="$PATCH_BIN" skip=5 of="$PATCH_WORKING" seek=28712 count=2 conv=notrunc
		rm -f "$PATCH_BIN"
		mount -o bind "$PATCH_WORKING" "$PATCH_TARGET" || PATCH_FAIL=1
		if [ "$PATCH_FAIL" = "0" ]; then
			echo "[BLEEMSYNC](INFO) patched out H+S statement"
		else
			echo "[BLEEMSYNC](FAIL) failed to patch out H+S statement, continuing anyway..."
		fi
	fi
	
	echo 0 > /sys/class/leds/red/brightness
	echo "[BLEEMSYNC](INFO) completed bleemsync boot"
	
	killall -s KILL sdl_display

	booted=0

	[ "$boot_target_stock_UI" = "1" ] && [ "$booted" = "0" ] && booted=1 && launch_StockUI
	[ "$boot_target_stock_BM" = "1" ] && [ "$booted" = "0" ] && booted=1 && launch_BootMenu
	[ "$boot_target_stock_RA" = "1" ] && [ "$booted" = "0" ] && booted=1 && launch_RetroArch
	
	#Cleanup and shutdown (If active telnet session don't shutdown console.)
	if [ "$(who | wc -l)" = "1" ]; then
		while true; do
			sleep 999
		done		
	else
		[ -d "/tmp/ra_cache" ] && rm -rf "/tmp/ra_cache"
		sync
		sync
		echo "[BLEEMSYNC](Executed) execute_bleemsync_func()"
		reboot
	fi
	exit 0
}
